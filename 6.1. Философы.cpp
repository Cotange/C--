#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>

using namespace std;

//Задача на многопоточное программирование. Наглядно реализовать задачу обедающих философов

//Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. 
//На столе между каждой парой ближайших философов лежит по одной вилке.
//Каждый философ может либо есть, либо размышлять. 
//Приём пищи не ограничен количеством оставшихся спагетти — подразумевается бесконечный запас. 
//Тем не менее, философ может есть только тогда, когда держит две вилки — взятую справа и слева.
//Каждый философ может взять ближайшую вилку (если она доступна) или положить — если он уже держит её. 
//Взятие каждой вилки и возвращение её на стол являются раздельными действиями, которые должны выполняться одно за другим.
//Вопрос задачи заключается в том, чтобы разработать модель поведения (параллельный алгоритм), 
//при котором ни один из философов не будет голодать, то есть будет вечно чередовать приём пищи и размышления. 

const int сount_phils = 5;

mutex forks[сount_phils];
condition_variable cv;

void phil(int id) 
{
  while (true) //Оно в конечном итоге не работает :(
  {
    printf("%d-й философ размышляет ", id+1); //Я сделал такой странный вывод текста потому, что, видимо, вследствие многопоточности при использовании cout выводятся не все элементы...
    cout << endl; //Текст на разных строках (не всегда работает...)

    unique_lock<mutex> left_lock(forks[id]);
    printf("%d-й философ взял левую вилку ", id+1);
    cout << endl;
    unique_lock<mutex> right_lock(forks[(id + 1) % сount_phils]);
    printf("%d-й философ взял правую вилку ", id+1);
    cout << endl;

    printf("%d-й философ кушает ", id+1);
    cout << endl;
    this_thread::sleep_for(chrono::seconds(1));

    right_lock.unlock();
    printf("%d-й философ положил правую вилку ", id+1);
    cout << endl;
    left_lock.unlock();
    printf("%d-й философ положил левую вилку ", id+1);
    cout << endl;
  }
}

int main() 
{
  thread phils[сount_phils];

  for (int i = 0; i < сount_phils; i++) 
  {
    phils[i] = thread(phil, i);
  }

  for (int i = 0; i < сount_phils; i++) 
  {
    phils[i].join();
  }
}